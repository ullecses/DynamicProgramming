
<b> Binary Search <b>
Реализуйте бинарный поиск на массиве чисел, отсортированном в неубывающем порядке.

<b> Frog path <b>
В одном очень длинном и узком пруду по кувшинкам прыгает лягушка. Кувшинки в пруду расположены в один ряд. Лягушка начинает прыгать с первой кувшинки ряда и хочет закончить на последней. Но в силу вредности характера лягушка согласна прыгать только вперед через одну или через две кувшинки. Например, с кувшинки номер 1 она может прыгнуть лишь на кувшинки номер 3 и номер 4.
На некоторых кувшинках сидят комарики. А именно, на i-й кувшинке сидят ai комаров. Когда лягушка приземляется на кувшинку, она съедает всех комариков, сидящих на ней. Лягушка хочет спланировать свой маршрут так, чтобы съесть как можно больше комаров. Помогите ей: скажите, какие кувшинки она должна посетить на своем пути.

<b> Gamma Language <b>
Как стало известно, гамма-язык отличается от европейских языков наличием очень большого числа иероглифов. В недавно изданном справочнике по гамма-иероглифам содержатся 2 000 000 000 различных иероглифов, и каждому присвоен порядковый номер от 1 до 2 000 000 000. Правила приличия не позволяют использовать в одном связном гамма-тексте два раза один и тот же иероглиф. Текст X (возможно, пустой) называется общим подтекстом текстов A и B, если X может быть получен вычёркиванием некоторых иероглифов, как из A, так и из B. Наибольшим общим подтекстом двух текстов называется их общий подтекст, имеющий максимально возможную длину. Считается, что чем больше длина наибольшего общего подтекста, тем больше шансов того, что два текста написаны одним и тем же автором.
Заданы два текста A и B, содержащие соответственно n и m иероглифов. Тексты являются приличными, то есть каждый из них не содержит два раза один и тот же иероглиф. Каждый иероглиф задается своим номером, который является натуральным числом, не превышающим 2 000 000 000. Вам требуется определить длину наибольшего общего подтекста этих текстов.

<b> LCS <b>
Даны две последовательности A и B, каждая имеет длину nnn.
Найти наибольшее k, для которого существуют две последовательности индексов 0≤i1<i2<…<ik<n0 \le i_1 < i_2 < \ldots < i_k < n0≤i1​<i2​<…<ik​<n и 0≤j1<j2<…<jk<n0 \le j_1 < j_2 < \ldots < j_k < n0≤j1​<j2​<…<jk​<n, что Ai1=Bj1A_{i_1} = B_{j_1}Ai1​​=Bj1​​, Ai2=Bj2A_{i_2} = B_{j_2}Ai2​​=Bj2​​, …, Aik=BjkA_{i_k} = B_{j_k}Aik​​=Bjk​​.
Также нужно найти и сами последовательности индексов.

<b> LIS <b>
Необходимо из заданной числовой последовательности A, состоящей из n элементов, вычеркнуть минимальное число элементов так, чтобы оставшиеся элементы образовали строго возрастающую подпоследовательность элементов. Построенный алгоритм должен иметь трудоёмкость O(n log n).

<b> Matrix Multiplication <b>
Дана последовательность из s матриц A1, A2, …, As. Требуется определить, в каком порядке их следует перемножать, чтобы число атомарных операций умножения было минимальным. Матрицы предполагаются совместимыми по отношению к матричному умножению (т. е. число столбцов матрицы Ai − 1 совпадает с числом строк матрицы Ai).
Будем считать, что произведение матриц — операция, которая принимает на вход две матрицы размера k × m и m × n и возвращает матрицу размера k × n, затратив на это kmn атомарных операций умножения. (Базовый тип позволяет хранить любой элемент итоговой и любой возможной промежуточной матрицы, поэтому умножение двух элементов требует одной атомарной операции.)
Так как перемножение матриц ассоциативно, итоговая матрица не зависит от порядка выполнения операций умножения. Другими словами, нет разницы, в каком порядке расставляются скобки между множителями, результат будет один и тот же.

<b> Palindrome <b>
Вводится непустая строка S, которая имеет длину не более 7000 символов и состоит только из строчных латинских букв. Необходимо удалить из строки минимальное число символов так, чтобы получился палиндром (строка символов, которая читается слева направо и справа налево одинаково).

<b> StringConversion <b>
На вход подаются две символьные последовательности A и B, каждая последовательность непустая, состоит из маленьких латинских букв и имеет длину не более 1000 символов. Необходимо преобразовать последовательность A в последовательность B с минимальным суммарным штрафом, который определяется следующим образом:
удаление символа из строки A равно x баллов;
вставка символа в строку A равна y баллов;
замена символа в строке A на любой другой равна z баллов.

<b> SumOfTree <b>
Дано бинарное поисковое дерево, в котором ключи вершин являются целыми числами. Найдите сумму ключей всех вершин дерева.

<b> Units <b>
Дано число N. Необходимо определить, сколько есть бинарных строк длины N, в которых ровно K единиц.
